1. 基本类型和引用类型的值

   变量包含两种不同的数据类型

   - 基本类型值

     - 5种基本数据类型——**按值访问**

       可以直接操作保存在变量的中的实际值

       - Undefined
       - Null
       - Number
       - String
       - Boolean

   - 和引用类型值

     - 1中复杂数据类型——**按引用访问**

       保存在对象中，不允许直接访问内存中的地址，实际上是在操作对象的引用而不是实际的对象

       - Object

   动态属性

   - 只能给引用类型值动态添加属性

   复制变量值

   ​    从一个变量向另一个变量复制

   - 基本类型
     - 创建一个新的值，存储到新的变量中
   - 引用类型
     - 将储存在变量对象中的**地址**储存到新的变量中，**该地址的指向存储在堆中的对象**

   传递参数

   - **按值传递**

     和变量的复制一样

     - 基本类型值的传递如同基本类型值的复制

     - 引用类型值的传递如同引用类型值的复制

     - 参**数只按值传递**

       ```javascript
       function setName(obj) {
           obj.name = "Nicholas";
           obj = new Object();
           obj.name = "Greg";
       }
       
       var person = new Object();
       setName(person);
       alert(person.name); //"Nicholas"
       ```

   检测类型

   - 检测一个变量是不是基本类型——**typeof**

     - 不能检测引用类型（null->object）
     - 内部实现[[call]]方法的对象，返回"function"
       - 函数
       - 正则表达式

   - 检测一个变量是什么类型的对象——**instanceof**

     语法：`result = variable instanceof constructor`

2. 执行环境及作用域

   执行环境（important）（execution context）也称**环境**

   - 环境中所有的变量和函数都保存在——**变量对象（bariable object）**中(代码无法访问，解析器后台使用)
   - **全局执行环境**是最外围的执行环境
     - Web浏览器的的全局执行环境是window对象
       - 因此，所有全局全局变量和函数都是作为window的对象的属性和方法创建
   - 某个执行环境中所有代码执行完毕后，该环境被销毁
     - 变量和函数定义也被销毁
     - 全局环境直到程序退出——关闭网页或浏览器
   - **函数有自己的执行环境（局部）**
     - 执行流进入函数时，函数环境压入环境栈
     - 函数执行之后，弹栈
     - 控制权返回之前的执行环境
   - 代码在一个环境中执行时，会创建**作用域链**
     - 目的：保证对执行环境有权访问所有变量和函数有序访问
     - 作用域的最前端始终是当前执行代码所在环境的变量对象
       - 如果是函数则将**活动对象（activation object）**作为变量对象
         - arguments
       - 作用域中的下一个变量对象来自包含环境（外部环境）
       - 下一个变量对象来自下一个包含环境
       - 全局执行环境的变量对象始终都是作用域中的最后一个对象
     - 每个环境都可以**向上搜索作用域链**，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个
       执行环境

   延长作用域链

   - try-catch语句的catch块
   - with语句

   **没有块级作用域**

   - 变量声明
     - `var`声明的变量自动添加到最近的环境中
       - 函数内部，最近的环境是函数的局部环境
       - with语句中，最近的环境是函数环境
     - 初始化变量没有使用`var`声明，自动添加到全局作用域中
       - 隐式全局变量，不要使用
   - 查询标识符
     - 搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符
     - 如果在局部环境中找到
       了该标识符，搜索过程停止，变量就绪
     - 如果在局部环境中没有找到该变量名，则继续沿作用域链向上
       搜索
     - 搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味
       着该变量尚未声明。——**报错**

3. 垃圾收集

   自动垃圾收集机制

   - 原理：
     - 找出那些不再继续使用的变量，然后释放其占有的内存
   - 标记无用变量的策略
     - 标记清除
       - 方式
         - 翻转某个特殊的位
         - 使用“进入环境”和“离开环境”的列表
       - 策略
         - 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记
         - 去掉环境中的变量以及被环境中的变量引用的变量的标记
         - 再被加上标记
           的变量将被视为准备删除的变量
         - 销毁那些带标记的值并回收它们所占用的内存空间，垃圾收集器
           完成内存清除工作
     - 引用计数

   性能问题

   - 回收时机

   管理内存

   - 分配给Web浏览器的可用内存通常比分配给桌面应用程序的少
     - 防止网页耗尽全部系统内存而导致系统崩溃
     - 内存限制会影响到性能

   **解除引用（dereferencing）**

   - 一旦数据不再有用，最好通过将其值设置为null 来释放其引用

   - 适用于大多数全局变量和全局对象的属性

   - 局部变量会在它们离开执行环境时自动被解除引用

     ```javascript
     function createPerson(name){
         var localPerson = new Object();
         localPerson.name = name;
         return localPerson;
     }
     var globalPerson = createPerson("Nicholas");
     // 手工解除globalPerson 的引用
     globalPerson = null;
     ```

     - 解除一个值的引用并不意味着自动回收该值所占用的内存。
     - 解除引用的真正作用是让值脱离
       执行环境，以便垃圾收集器下次运行时将其回收。

4. 小结

   > JavaScript 变量可以用来保存两种类型的值：基本类型值和引用类型值。
   >
   > 基本类型的值源自以下5
   > 种基本数据类型：Undefined、Null、Boolean、Number 和String。
   >
   > 基本类型值和引用类型值具
   > 有以下特点：
   >
   >  基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
   >
   >  从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
   >
   >  引用类型的值是对象，保存在堆内存中；
   >
   >  包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
   >
   >  从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同
   > 一个对象；
   >
   >  确定一个值是哪种基本类型可以使用typeof 操作符，而确定一个值是哪种引用类型可以使instanceof 操作符

   > 所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执
   > 行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。
   >
   > 以下是关于执行环境的几
   > 点总结：
   >
   >  执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；
   >
   >  每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
   >
   >  函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全
   > 局环境；
   >
   >  全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
   >
   >  变量的执行环境有助于确定应该何时释放内存。

   > JavaScript 是一门具有自动垃圾收集机制的编程语言
   >
   >  离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。
   >
   >  “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然
   > 后再回收其内存。
   >
   >  另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript
   > 引擎目前都不再使用这种算法；但在IE 中访问非原生JavaScript 对象（如DOM 元素）时，这种
   > 算法仍然可能会导致问题。
   >
   >  当代码中存在循环引用现象时，“引用计数”算法就会导致问题。
   >
   >  解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回
   > 收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。
